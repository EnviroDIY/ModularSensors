/**
 * @file SDI12Sensors.cpp_0275
 * @copyright 2020 Stroud Water Research Center
 * Part of the EnviroDIY ModularSensors library for Arduino
 * @author Sara Geleskie Damiano <sdamiano@stroudcenter.org>
 *
 * @brief Implements the SDI12Sensors class.
 */

#define LIBCALL_ENABLEINTERRUPT  // To prevent compiler/linker crashes
#include <EnableInterrupt.h>     // To handle external and pin change interrupts

#include "SDI12Sensors.h"


// The constructor - need the number of measurements the sensor will return,
// SDI-12 address, the power pin, and the data pin
SDI12Sensors::SDI12Sensors(char SDI12address, int8_t powerPin, int8_t dataPin,
                           uint8_t       measurementsToAverage,
                           const char*   sensorName,
                           const uint8_t numReturnedVars,
                           uint32_t      warmUpTime_ms,
                           uint32_t      stabilizationTime_ms,
                           uint32_t      measurementTime_ms)
    : Sensor(sensorName, numReturnedVars, warmUpTime_ms, stabilizationTime_ms,
             measurementTime_ms, powerPin, dataPin, measurementsToAverage),
      _SDI12Internal(dataPin) {
    _SDI12address = SDI12address;
}
SDI12Sensors::SDI12Sensors(char* SDI12address, int8_t powerPin, int8_t dataPin,
                           uint8_t       measurementsToAverage,
                           const char*   sensorName,
                           const uint8_t numReturnedVars,
                           uint32_t      warmUpTime_ms,
                           uint32_t      stabilizationTime_ms,
                           uint32_t      measurementTime_ms)
    : Sensor(sensorName, numReturnedVars, warmUpTime_ms, stabilizationTime_ms,
             measurementTime_ms, powerPin, dataPin, measurementsToAverage),
      _SDI12Internal(dataPin) {
    _SDI12address = *SDI12address;
}
SDI12Sensors::SDI12Sensors(int SDI12address, int8_t powerPin, int8_t dataPin,
                           uint8_t       measurementsToAverage,
                           const char*   sensorName,
                           const uint8_t numReturnedVars,
                           uint32_t      warmUpTime_ms,
                           uint32_t      stabilizationTime_ms,
                           uint32_t      measurementTime_ms)
    : Sensor(sensorName, numReturnedVars, warmUpTime_ms, stabilizationTime_ms,
             measurementTime_ms, powerPin, dataPin, measurementsToAverage),
      _SDI12Internal(dataPin) {
    _SDI12address = SDI12address + '0';
}
// Destructor
SDI12Sensors::~SDI12Sensors() {}


bool SDI12Sensors::setup(void) {
    bool retVal =
        Sensor::setup();  // this will set pin modes and the setup status bit

    // This sensor needs power for setup!
    bool wasOn = checkPowerOn();
    if (!wasOn) { powerUp(); }
    waitForWarmUp();

    // Begin the SDI-12 interface
    _SDI12Internal.begin();

    // Library default timeout should be 150ms, which is 10 times that specified
    // by the SDI-12 protocol for a sensor response.
    // May want to bump it up even further here.
    _SDI12Internal.setTimeout(150);
    // Force the timeout value to be -9999 (This should be library default.)
    _SDI12Internal.setTimeoutValue(-9999);

#if defined __AVR__ || defined ARDUINO_ARCH_AVR
    // Allow the SDI-12 library access to interrupts
    MS_DBG(F("Enabling interrupts for SDI12 on pin"), _dataPin);
    enableInterrupt(_dataPin, SDI12::handleInterrupt, CHANGE);
#endif

    retVal &= getSensorInfo();

    // Empty the SDI-12 buffer
    _SDI12Internal.clearBuffer();

    // De-activate the SDI-12 Object
    // Use end() instead of just forceHold to un-set the timers
    _SDI12Internal.end();

    // Turn the power back off it it had been turned on
    if (!wasOn) { powerDown(); }

    if (!retVal) {  // if set-up failed
        // Set the status error bit (bit 7)
        _sensorStatus |= 0b10000000;
        // UN-set the set-up bit (bit 0) since setup failed!
        _sensorStatus &= 0b11111110;
    }

    return retVal;
}


bool SDI12Sensors::requestSensorAcknowledgement(void) {
    // Empty the buffer
    _SDI12Internal.clearBuffer();

    MS_DBG(F("  Asking for sensor acknowlegement"));
    String myCommand = "";
    myCommand += static_cast<char>(_SDI12address);
    myCommand += "!";  // sends 'acknowledge active' command [address][!]

    bool    didAcknowledge = false;
    uint8_t ntries         = 0;
    while (!didAcknowledge && ntries < 5) {
        _SDI12Internal.sendCommand(myCommand);
        MS_DBG(F("    >>>"), myCommand);
        delay(30);

        // wait for acknowlegement with format:
        // [address]<CR><LF>
        String sdiResponse = _SDI12Internal.readStringUntil('\n');
        sdiResponse.trim();
        MS_DBG(F("    <<<"), sdiResponse);

        // Empty the buffer again
        _SDI12Internal.clearBuffer();

        if (sdiResponse == String(_SDI12address)) {
            MS_DBG(F("   "), getSensorNameAndLocation(),
                   F("replied as expected."));
            didAcknowledge = true;
        } else if (sdiResponse.startsWith(String(_SDI12address))) {
            MS_DBG(F("   "), getSensorNameAndLocation(),
                   F("replied, unexpectedly"));
            didAcknowledge = true;
        } else {
            MS_DBG(F("   "), getSensorNameAndLocation(), F("did not reply!"));
            didAcknowledge = false;
        }

        ntries++;
    }

    return didAcknowledge;
}


// A helper function to run the "sensor info" SDI12 command
bool SDI12Sensors::getSensorInfo(void) {
    // MS_DBG(F("   Activating SDI-12 instance for"),
    //        getSensorNameAndLocation());
    // Check if this the currently active SDI-12 Object
    bool wasActive = _SDI12Internal.isActive();
    // If it wasn't active, activate it now.
    // Use begin() instead of just setActive() to ensure timer is set correctly.
    // if (wasActive) {
    //     MS_DBG(F("   SDI-12 instance for"), getSensorNameAndLocation(),
    //            F("was already active!"));
    // }
    if (!wasActive) _SDI12Internal.begin();
    // Empty the buffer
    _SDI12Internal.clearBuffer();

    // Check that the sensor is there and responding
    if (!requestSensorAcknowledgement()) return false;

    MS_DBG(F("  Getting sensor info"));
    String myCommand = "";
    myCommand += static_cast<char>(_SDI12address);
    myCommand += "I!";  // sends 'info' command [address][I][!]
    _SDI12Internal.sendCommand(myCommand);
    MS_DBG(F("    >>>"), myCommand);
    delay(30);

    // wait for acknowlegement with format:
    // [address][SDI12 version supported (2 char)][vendor (8 char)][model (6
    // char)][version (3 char)][serial number (<14 char)]<CR><LF>
    String sdiResponse = _SDI12Internal.readStringUntil('\n');
    sdiResponse.trim();
    MS_DBG(F("    <<<"), sdiResponse);

    // Empty the buffer again
    _SDI12Internal.clearBuffer();

    // De-activate the SDI-12 Object
    // Use end() instead of just forceHold to un-set the timers
    if (!wasActive) _SDI12Internal.end();

    if (sdiResponse.length() > 1) {
        String sdi12Address = sdiResponse.substring(0, 1);
        MS_DBG(F("  SDI12 Address:"), sdi12Address);
        float sdi12Version = sdiResponse.substring(1, 3).toFloat();
        sdi12Version /= 10;
        MS_DBG(F("  SDI12 Version:"), sdi12Version);
        _sensorVendor = sdiResponse.substring(3, 11);
        _sensorVendor.trim();
        MS_DBG(F("  Sensor Vendor:"), _sensorVendor);
        _sensorModel = sdiResponse.substring(11, 17);
        _sensorModel.trim();
        MS_DBG(F("  Sensor Model:"), _sensorModel);
        _sensorVersion = sdiResponse.substring(17, 20);
        _sensorVersion.trim();
        MS_DBG(F("  Sensor Version:"), _sensorVersion);
        _sensorSerialNumber = sdiResponse.substring(20);
        _sensorSerialNumber.trim();
        MS_DBG(F("  Sensor Serial Number:"), _sensorSerialNumber);
        return true;
    } else {
        return false;
    }
}


// The sensor vendor
String SDI12Sensors::getSensorVendor(void) {
    return _sensorVendor;
}

// The sensor model
String SDI12Sensors::getSensorModel(void) {
    return _sensorModel;
}

// The sensor version
String SDI12Sensors::getSensorVersion(void) {
    return _sensorVersion;
}

// The sensor serial number
String SDI12Sensors::getSensorSerialNumber(void) {
    return _sensorSerialNumber;
}


// The sensor installation location on the Mayfly
String SDI12Sensors::getSensorLocation(void) {
    String sensorLocation = F("SDI12-");
    sensorLocation += String(_SDI12address) + F("_Pin") + String(_dataPin);
    return sensorLocation;
}


#ifndef MS_SDI12_NON_CONCURRENT
// Sending the command to get a concurrent measurement
bool SDI12Sensors::startSingleMeasurement(void) {
    // Sensor::startSingleMeasurement() checks that if it's awake/active and
    // sets the timestamp and status bits.  If it returns false, there's no
    // reason to go on.
    if (!Sensor::startSingleMeasurement()) return false;

    String startCommand;
    String sdiResponse;
    bool   wasActive;

    // MS_DBG(F("   Activating SDI-12 instance for"),
    //        getSensorNameAndLocation());
    // Check if this the currently active SDI-12 Object
    wasActive = _SDI12Internal.isActive();
    // if (wasActive) {
    //     MS_DBG(F("   SDI-12 instance for"), getSensorNameAndLocation(),
    //            F("was already active!"));
    // }
    // If it wasn't active, activate it now.
    // Use begin() instead of just setActive() to ensure timer is set correctly.
    if (!wasActive) _SDI12Internal.begin();
    // Empty the buffer
    _SDI12Internal.clearBuffer();

    // Check that the sensor is there and responding
    if (!requestSensorAcknowledgement()) {
        _millisMeasurementRequested = 0;
        _sensorStatus &= 0b10111111;
        return false;
    }

    MS_DBG(F("  Beginning concurrent measurement on"),
           getSensorNameAndLocation());
    startCommand = "";
    startCommand += _SDI12address;
    startCommand +=
        "C!";  // Start concurrent measurement - format  [address]['C'][!]
    _SDI12Internal.sendCommand(startCommand);
    delay(30);  // It just needs this little delay
    MS_DBG(F("    >>>"), startCommand);

    // wait for acknowlegement with format
    // [address][ttt (3 char, seconds)][number of values to be returned,
    // 0-9]<CR><LF>
    sdiResponse = _SDI12Internal.readStringUntil('\n');
    sdiResponse.trim();
    _SDI12Internal.clearBuffer();
    MS_DBG(F("    <<<"), sdiResponse);

    // Empty the buffer again
    _SDI12Internal.clearBuffer();

    // De-activate the SDI-12 Object
    // Use end() instead of just forceHold to un-set the timers
    if (!wasActive) _SDI12Internal.end();

    // Verify the number of results the sensor will send
    uint8_t numVariables = sdiResponse.substring(4).toInt();
    if (numVariables != _numReturnedValues) {
        PRINTOUT(numVariables, F("results expected"),
                 F("This differs from the sensor's standard design of"),
                 _numReturnedValues, F("measurements!!"));
    }

    // Set the times we've activated the sensor and asked for a measurement
    if (sdiResponse.length() > 0) {
        MS_DBG(F("    Concurrent measurement started."));
        // Update the time that a measurement was requested
        _millisMeasurementRequested = millis();
        // Set the status bit for measurement start success (bit 6)
        _sensorStatus |= 0b01000000;
        return true;
    } else {
        MS_DBG(getSensorNameAndLocation(),
               F("did not respond to measurement request!"));
        _millisMeasurementRequested = 0;
        _sensorStatus &= 0b10111111;
        return false;
    }
}
#endif

bool SDI12Sensors::getResults(void) {
    // MS_DBG(F("   Activating SDI-12 instance for"),
    //        getSensorNameAndLocation());
    // Check if this the currently active SDI-12 Object
    bool wasActive = _SDI12Internal.isActive();
    // if (wasActive) {
    //     MS_DBG(F("   SDI-12 instance for"), getSensorNameAndLocation(),
    //            F("was already active!"));
    // }
    // If it wasn't active, activate it now.
    // Use begin() instead of just setActive() to ensure timer is set
    // correctly.
    if (!wasActive) _SDI12Internal.begin();
    // Empty the buffer
    _SDI12Internal.clearBuffer();

    MS_DBG(getSensorNameAndLocation(), F("is reporting:"));
    uint8_t resultsReceived = 0;
    uint8_t cmd_number      = 0;
    while (resultsReceived < _numReturnedValues && cmd_number <= 9) {
        bool   gotResults     = false;
        String getDataCommand = "";
        getDataCommand += _SDI12address;
        // SDI-12 command to get data [address][D][dataOption][!]
        getDataCommand += "D";
        getDataCommand += cmd_number;
        getDataCommand += "!";
        _SDI12Internal.sendCommand(getDataCommand);
        delay(30);  // It just needs this little delay
        MS_DBG(F("    >>>"), getDataCommand);

        uint32_t start = millis();
        while (_SDI12Internal.available() < 3 && (millis() - start) < 1500) {}
        MS_DBG(F("  Receiving results from"), getSensorNameAndLocation());
        MS_DBG(F("    <<<"), static_cast<char>(_SDI12Internal.read()));
        // ^^ ignore the repeated SDI12 address

        while (_SDI12Internal.available()) {
            int c = _SDI12Internal.peek();
            if (c == '-' || (c >= '0' && c <= '9') || c == '.') {
                float result = _SDI12Internal.parseFloat(SKIP_NONE);
                // The SDI-12 library should return -9999 on timeout
                if (result == -9999 || isnan(result)) result = -9999;
                MS_DBG(F("    <<<"), String(result, 10));
                verifyAndAddMeasurementResult(resultsReceived, result);
                if (result != -9999) {
                    gotResults = true;
                    resultsReceived++;
                }
            } else if (c >= 0 && c != '\r' && c != '\n') {
                MS_DBG(F("    <<<"), static_cast<char>(_SDI12Internal.read()));
            } else {  // no point -1's and new lines to debugging port
                _SDI12Internal.read();
            }
            delay(10);  // 1 character ~ 7.5ms
        }
        if (!gotResults) {
            MS_DBG(F("  No results received, will not continue requests!"));
            break;  // don't do another loop if we got nothing
        }
        MS_DBG(F("  Total Results Received: "), resultsReceived,
               F(", Remaining: "), _numReturnedValues - resultsReceived);
        cmd_number++;
    }
    // String sdiResponse = _SDI12Internal.readStringUntil('\n');
    // sdiResponse.trim();
    // _SDI12Internal.clearBuffer();
    // MS_DBG(F("    <<<"), sdiResponse);

    // Empty the buffer again
    _SDI12Internal.clearBuffer();

    // De-activate the SDI-12 Object
    // Use end() instead of just forceHold to un-set the timers
    if (!wasActive) _SDI12Internal.end();

    return _numReturnedValues == resultsReceived;
}


#ifndef MS_SDI12_NON_CONCURRENT
bool SDI12Sensors::addSingleMeasurementResult(void) {
    bool success = false;

    // Check a measurement was *successfully* started (status bit 6 set)
    // Only go on to get a result if it was
    if (bitRead(_sensorStatus, 6)) {
        success = getResults();
    } else {
        // If there's no measurement, need to make sure we send over all
        // of the "failed" result values
        MS_DBG(getSensorNameAndLocation(), F("is not currently measuring!"));
        for (uint8_t i = 0; i < _numReturnedValues; i++) {
            verifyAndAddMeasurementResult(i, static_cast<float>(-9999));
        }
    }

    // Unset the time stamp for the beginning of this measurement
    _millisMeasurementRequested = 0;
    // Unset the status bits for a measurement request (bits 5 & 6)
    _sensorStatus &= 0b10011111;

    return success;
}
#else
bool SDI12Sensors::addSingleMeasurementResult(void) {
    bool success = false;

    String startCommand;
    String sdiResponse;
    bool   wasActive;

    // MS_DBG(F("   Activating SDI-12 instance for"),
    //        getSensorNameAndLocation());
    // Check if this the currently active SDI-12 Object
    bool wasActive = _SDI12Internal.isActive();
    // if (wasActive) {
    //     MS_DBG(F("   SDI-12 instance for"), getSensorNameAndLocation(),
    //            F("was already active!"));
    // }
    // If it wasn't active, activate it now.
    // Use begin() instead of just setActive() to ensure timer is set
    // correctly.
    if (!wasActive) _SDI12Internal.begin();
    // Empty the buffer
    _SDI12Internal.clearBuffer();

    MS_DBG(F("  Beginning concurrent measurement on"),
           getSensorNameAndLocation());
    startCommand = "";
    startCommand += _SDI12address;
    startCommand +=
        "M!";  // Start concurrent measurement - format  [address]['C'][!]
    _SDI12Internal.sendCommand(startCommand);
    delay(30);  // It just needs this little delay
    MS_DBG(F("    >>>"), startCommand);

    // wait for acknowlegement with format
    // [address][ttt (3 char, seconds)][number of values to be returned,
    // 0-9]<CR><LF>
    sdiResponse = _SDI12Internal.readStringUntil('\n');
    sdiResponse.trim();
    _SDI12Internal.clearBuffer();
    MS_DBG(F("    <<<"), sdiResponse);

    // find out how long we have to wait (in seconds).
    uint8_t wait = sdiResponse.substring(1, 4).toInt();

    // Verify the number of results the sensor will send
    uint8_t numVariables = sdiResponse.substring(4).toInt();
    if (numVariables != _numReturnedValues) {
        PRINTOUT(numVariables, F("results expected"),
                 F("This differs from the sensor's standard design of"),
                 _numReturnedValues, F("measurements!!"));
    }

    // Set the times we've activated the sensor and asked for a measurement
    if (sdiResponse.length() > 0) {
        MS_DBG(F("    NON-concurrent measurement started."));
        // Update the time that a measurement was requested
        _millisMeasurementRequested = millis();
        // Set the status bit for measurement start success (bit 6)
        _sensorStatus |= 0b01000000;
    } else {
        MS_DBG(getSensorNameAndLocation(),
               F("did not respond to measurement request!"));
        _millisMeasurementRequested = 0;
        _sensorStatus &= 0b10111111;
    }

    // Check a measurement was *successfully* started (status bit 6 set)
    // Only go on to get a result if it was
    if (bitRead(_sensorStatus, 6)) {
        // Since this is not a concurrent measurement, we must sit around and
        // wait for the sensor to issue a service request telling us that the
        // measurement is ready.

        unsigned long timerStart = millis();
        while ((millis() - timerStart) < (1000 * (wait))) {
            if (_SDI12Internal.available())  // sensor can interrupt us to let
                                             // us know it is done early
            {
                MS_DBG(F("    <<<"), _SDI12Internal.readStringUntil('\n'));
                _SDI12Internal.clearBuffer();
                break;
            }
        }
        // Wait for anything else and clear it out
        delay(30);
        _SDI12Internal.clearBuffer();

        // get the results
        success = getResults();

        // Empty the buffer again
        _SDI12Internal.clearBuffer();

        // De-activate the SDI-12 Object
        // Use end() instead of just forceHold to un-set the timers
        if (!wasActive) _SDI12Internal.end();
    } else {
        // If there's no measurement, need to make sure we send over all
        // of the "failed" result values
        MS_DBG(getSensorNameAndLocation(), F("is not currently measuring!"));
        for (uint8_t i = 0; i < _numReturnedValues; i++) {
            verifyAndAddMeasurementResult(i, static_cast<float>(-9999));
        }
    }

    // Unset the time stamp for the beginning of this measurement
    _millisMeasurementRequested = 0;
    // Unset the status bits for a measurement request (bits 5 & 6)
    _sensorStatus &= 0b10011111;

    return success;
}
#endif